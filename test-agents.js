#!/usr/bin/env node

/**
 * Script de test pour le syst√®me multi-agent
 * Teste le fonctionnement de chaque agent et de l'orchestrateur
 */

const path = require('path');

// Import des agents
const AgentBase = require('./agents/base/AgentBase');
const PromptRefinementAgent = require('./agents/PromptRefinementAgent');
const DistributionAgent = require('./agents/DistributionAgent');
const CollectionAgent = require('./agents/CollectionAgent');
const InnovationAgent = require('./agents/InnovationAgent');
const VerificationAgent = require('./agents/VerificationAgent');
const SynthesisAgent = require('./agents/SynthesisAgent');
const Orchestrator = require('./agents/orchestrator');

class AgentTester {
    constructor() {
        this.testResults = [];
        this.errors = [];
    }

    /**
     * Ex√©cute tous les tests
     */
    async runAllTests() {
        console.log('üß™ D√âMARRAGE DES TESTS DU SYST√àME MULTI-AGENT');
        console.log('=' .repeat(50));

        try {
            // Tests individuels des agents
            await this.testAgentBase();
            await this.testPromptRefinementAgent();
            await this.testDistributionAgent();
            await this.testCollectionAgent();
            await this.testInnovationAgent();
            await this.testVerificationAgent();
            await this.testSynthesisAgent();

            // Test du workflow complet
            await this.testCompleteWorkflow();

            // Affichage des r√©sultats
            this.displayResults();

        } catch (error) {
            console.error('‚ùå Erreur lors des tests:', error.message);
            this.errors.push(error);
        }
    }

    /**
     * Test de la classe de base AgentBase
     */
    async testAgentBase() {
        console.log('\nüìã Test AgentBase...');
        
        try {
            const agent = new AgentBase('TestAgent', 'Agent de test', ['test']);
            
            // Test des propri√©t√©s de base
            this.assert(agent.name === 'TestAgent', 'Nom de l\'agent correct');
            this.assert(agent.role === 'Agent de test', 'R√¥le de l\'agent correct');
            this.assert(agent.status === 'inactive', 'Statut initial correct');
            
            // Test de changement de statut
            agent.setStatus('active');
            this.assert(agent.status === 'active', 'Changement de statut fonctionne');
            
            // Test de validation d'entr√©e
            this.assert(agent.validateInput({test: 'data'}), 'Validation d\'entr√©e valide');
            this.assert(!agent.validateInput(null), 'Validation d\'entr√©e invalide');
            
            // Test des informations de l'agent
            const info = agent.getInfo();
            this.assert(typeof info === 'object', 'getInfo retourne un objet');
            this.assert(info.name === 'TestAgent', 'Info contient le nom correct');
            
            this.addTestResult('AgentBase', true, 'Tests de base r√©ussis');
            
        } catch (error) {
            this.addTestResult('AgentBase', false, error.message);
        }
    }

    /**
     * Test de l'agent d'affinement de prompt
     */
    async testPromptRefinementAgent() {
        console.log('\nüîß Test PromptRefinementAgent...');
        
        try {
            const agent = new PromptRefinementAgent();
            
            const testInput = {
                prompt: 'Comment cr√©er une API REST ?',
                context: { domain: 'code' },
                options: { level: 'moderate' }
            };
            
            const result = await agent.execute(testInput);
            
            this.assert(result.originalPrompt === testInput.prompt, 'Prompt original pr√©serv√©');
            this.assert(result.refinedPrompt && result.refinedPrompt.length > 0, 'Prompt affin√© g√©n√©r√©');
            this.assert(result.analysis && typeof result.analysis === 'object', 'Analyse g√©n√©r√©e');
            this.assert(Array.isArray(result.suggestions), 'Suggestions g√©n√©r√©es');
            this.assert(typeof result.confidence === 'number', 'Score de confiance g√©n√©r√©');
            
            this.addTestResult('PromptRefinementAgent', true, `Prompt affin√© avec ${result.suggestions.length} suggestions`);
            
        } catch (error) {
            this.addTestResult('PromptRefinementAgent', false, error.message);
        }
    }

    /**
     * Test de l'agent de distribution
     */
    async testDistributionAgent() {
        console.log('\nüì° Test DistributionAgent...');
        
        try {
            const agent = new DistributionAgent();
            
            const testInput = {
                refinedPrompt: 'Comment cr√©er une API REST avec Node.js et Express ?',
                taskType: 'code',
                maxSources: 3,
                timeout: 5000
            };
            
            const result = await agent.execute(testInput);
            
            this.assert(result.sourcesUsed && Array.isArray(result.sourcesUsed), 'Sources utilis√©es list√©es');
            this.assert(result.distributionResults && Array.isArray(result.distributionResults), 'R√©sultats de distribution g√©n√©r√©s');
            this.assert(result.aggregatedResult && typeof result.aggregatedResult === 'object', 'R√©sultat agr√©g√© g√©n√©r√©');
            this.assert(typeof result.efficiency === 'object', 'M√©triques d\'efficacit√© g√©n√©r√©es');
            
            this.addTestResult('DistributionAgent', true, `Distribu√© vers ${result.sourcesUsed.length} sources`);
            
        } catch (error) {
            this.addTestResult('DistributionAgent', false, error.message);
        }
    }

    /**
     * Test de l'agent de collecte
     */
    async testCollectionAgent() {
        console.log('\nüìä Test CollectionAgent...');
        
        try {
            const agent = new CollectionAgent();
            
            // Simuler des r√©sultats de distribution
            const mockDistributionResults = {
                sourcesUsed: ['LLaMA 3', 'Mistral', 'CodeGemma'],
                distributionResults: [
                    { success: true, source: { name: 'LLaMA 3', type: 'language_model' }, data: { content: 'Test content 1', confidence: 0.8 }, responseTime: 1000 },
                    { success: true, source: { name: 'Mistral', type: 'language_model' }, data: { content: 'Test content 2', confidence: 0.9 }, responseTime: 1200 },
                    { success: true, source: { name: 'CodeGemma', type: 'code_model' }, data: { content: 'Test code content', confidence: 0.85 }, responseTime: 800 }
                ],
                aggregatedResult: {
                    reliability_score: 0.85,
                    successful_sources: 3,
                    average_response_time: 1000
                }
            };
            
            const testInput = {
                distributionResults: mockDistributionResults,
                originalPrompt: 'Comment cr√©er une API REST ?',
                taskType: 'code'
            };
            
            const result = await agent.execute(testInput);
            
            this.assert(result.dataAnalysis && typeof result.dataAnalysis === 'object', 'Analyse des donn√©es g√©n√©r√©e');
            this.assert(result.keyFindings && Array.isArray(result.keyFindings), '√âl√©ments cl√©s identifi√©s');
            this.assert(result.sourceCorrelation && typeof result.sourceCorrelation === 'object', 'Corr√©lation des sources g√©n√©r√©e');
            this.assert(result.synthesis && typeof result.synthesis === 'object', 'Synth√®se g√©n√©r√©e');
            this.assert(result.qualityAssessment && typeof result.qualityAssessment === 'object', '√âvaluation qualit√© g√©n√©r√©e');
            
            this.addTestResult('CollectionAgent', true, `${result.keyFindings.length} √©l√©ments cl√©s collect√©s`);
            
        } catch (error) {
            this.addTestResult('CollectionAgent', false, error.message);
        }
    }

    /**
     * Test de l'agent d'innovation
     */
    async testInnovationAgent() {
        console.log('\nüí° Test InnovationAgent...');
        
        try {
            const agent = new InnovationAgent();
            
            // Simuler une synth√®se de collection
            const mockCollectionSynthesis = {
                synthesis: {
                    main_points: [{ point: 'API REST structure' }, { point: 'Express.js framework' }],
                    confidence_level: 0.8,
                    recommended_actions: ['Implement endpoints', 'Add middleware']
                },
                keyFindings: [
                    { category: 'code', content: 'Express.js examples', importance: 'high', confidence: 0.9 },
                    { category: 'performance', content: 'Optimization tips', importance: 'medium', confidence: 0.7 }
                ],
                qualityAssessment: {
                    overall_quality: 0.85,
                    completeness: 0.8,
                    reliability: 0.9
                }
            };
            
            const testInput = {
                collectionSynthesis: mockCollectionSynthesis,
                originalPrompt: 'Comment cr√©er une API REST ?',
                taskType: 'code',
                innovationLevel: 'moderate'
            };
            
            const result = await agent.execute(testInput);
            
            this.assert(result.solutionAnalysis && typeof result.solutionAnalysis === 'object', 'Analyse de solution g√©n√©r√©e');
            this.assert(result.opportunities && Array.isArray(result.opportunities), 'Opportunit√©s identifi√©es');
            this.assert(result.improvements && Array.isArray(result.improvements), 'Am√©liorations g√©n√©r√©es');
            this.assert(result.riskAnalysis && typeof result.riskAnalysis === 'object', 'Analyse des risques g√©n√©r√©e');
            this.assert(result.recommendations && typeof result.recommendations === 'object', 'Recommandations g√©n√©r√©es');
            
            this.addTestResult('InnovationAgent', true, `${result.improvements.length} am√©liorations propos√©es`);
            
        } catch (error) {
            this.addTestResult('InnovationAgent', false, error.message);
        }
    }

    /**
     * Test de l'agent de v√©rification
     */
    async testVerificationAgent() {
        console.log('\n‚úÖ Test VerificationAgent...');
        
        try {
            const agent = new VerificationAgent();
            
            // Simuler des innovations
            const mockInnovations = {
                improvements: [
                    {
                        id: 'improvement_1',
                        title: 'Performance Optimization',
                        description: 'Optimize API response times',
                        category: 'performance',
                        priority: 'high',
                        implementation: ['Step 1', 'Step 2'],
                        expected_benefits: ['Faster responses'],
                        timeline: '2-4 weeks',
                        innovation_score: 0.8
                    }
                ],
                riskAnalysis: {
                    success_probability: 0.8
                },
                innovationMetrics: {
                    innovation_potential: 0.7
                }
            };
            
            const mockCollectionSynthesis = {
                synthesis: { confidence_level: 0.8 },
                qualityAssessment: { overall_quality: 0.85 }
            };
            
            const testInput = {
                innovations: mockInnovations,
                collectionSynthesis: mockCollectionSynthesis,
                originalPrompt: 'Comment cr√©er une API REST ?',
                taskType: 'code'
            };
            
            const result = await agent.execute(testInput);
            
            this.assert(result.verification_summary && typeof result.verification_summary === 'object', 'R√©sum√© de v√©rification g√©n√©r√©');
            this.assert(result.coherence_check && typeof result.coherence_check === 'object', 'V√©rification de coh√©rence effectu√©e');
            this.assert(result.improvement_validation && typeof result.improvement_validation === 'object', 'Validation des am√©liorations effectu√©e');
            this.assert(result.quality_tests && typeof result.quality_tests === 'object', 'Tests de qualit√© effectu√©s');
            this.assert(result.final_validation && typeof result.final_validation === 'object', 'Validation finale effectu√©e');
            
            this.addTestResult('VerificationAgent', true, `Score de v√©rification: ${result.verification_summary.score}`);
            
        } catch (error) {
            this.addTestResult('VerificationAgent', false, error.message);
        }
    }

    /**
     * Test de l'agent de synth√®se
     */
    async testSynthesisAgent() {
        console.log('\nüìã Test SynthesisAgent...');
        
        try {
            const agent = new SynthesisAgent();
            
            // Simuler tous les r√©sultats pr√©c√©dents
            const mockInput = {
                originalPrompt: 'Comment cr√©er une API REST ?',
                promptRefinement: {
                    originalPrompt: 'Comment cr√©er une API REST ?',
                    refinedPrompt: 'Comment cr√©er une API REST robuste avec Node.js et Express ?',
                    confidence: 0.8
                },
                distributionResults: {
                    sourcesUsed: ['LLaMA 3', 'Mistral'],
                    efficiency: { overall_score: 0.85 }
                },
                collectionSynthesis: {
                    synthesis: { confidence_level: 0.8 },
                    keyFindings: [{ category: 'code', content: 'Express example' }],
                    qualityAssessment: { overall_quality: 0.85 }
                },
                innovations: {
                    improvements: [{ title: 'Performance boost', innovation_score: 0.8 }],
                    innovationMetrics: { innovation_potential: 0.7 }
                },
                verification: {
                    verification_summary: { score: 85 },
                    verification_metrics: { overall_confidence: 0.8 },
                    final_validation: { overall_score: 85, final_status: 'approved' }
                },
                taskType: 'code'
            };
            
            const result = await agent.execute(mockInput);
            
            this.assert(result.synthesis_metadata && typeof result.synthesis_metadata === 'object', 'M√©tadonn√©es de synth√®se g√©n√©r√©es');
            this.assert(result.final_response && typeof result.final_response === 'object', 'R√©ponse finale g√©n√©r√©e');
            this.assert(result.workflow_analysis && typeof result.workflow_analysis === 'object', 'Analyse du workflow g√©n√©r√©e');
            this.assert(result.quality_metrics && typeof result.quality_metrics === 'object', 'M√©triques de qualit√© g√©n√©r√©es');
            this.assert(result.appendices && typeof result.appendices === 'object', 'Annexes g√©n√©r√©es');
            
            this.addTestResult('SynthesisAgent', true, `Confiance finale: ${Math.round(result.quality_metrics.overall_confidence * 100)}%`);
            
        } catch (error) {
            this.addTestResult('SynthesisAgent', false, error.message);
        }
    }

    /**
     * Test du workflow complet via l'orchestrateur
     */
    async testCompleteWorkflow() {
        console.log('\nüéØ Test du workflow complet...');
        
        try {
            const orchestrator = new Orchestrator();
            
            // Ajouter un listener pour suivre la progression
            let progressEvents = [];
            orchestrator.on('all', (event, data) => {
                progressEvents.push({ event, data });
            });
            
            const testPrompt = 'Comment cr√©er une API REST s√©curis√©e avec Node.js ?';
            const options = {
                taskType: 'code',
                innovationLevel: 'moderate',
                maxSources: 2,
                timeout: 10000
            };
            
            const result = await orchestrator.processRequest(testPrompt, options);
            
            this.assert(result.workflow_metadata && typeof result.workflow_metadata === 'object', 'M√©tadonn√©es du workflow g√©n√©r√©es');
            this.assert(result.response && typeof result.response === 'object', 'R√©ponse principale g√©n√©r√©e');
            this.assert(result.status && result.status.success === true, 'Workflow termin√© avec succ√®s');
            this.assert(result.quality_metrics && typeof result.quality_metrics === 'object', 'M√©triques de qualit√© g√©n√©r√©es');
            this.assert(progressEvents.length > 0, '√âv√©nements de progression √©mis');
            
            // V√©rifier que toutes les phases ont √©t√© ex√©cut√©es
            const phaseEvents = progressEvents.filter(p => p.event.includes('phase'));
            this.assert(phaseEvents.length >= 4, 'Les deux phases ont √©t√© ex√©cut√©es'); // start/complete pour chaque phase
            
            this.addTestResult('Orchestrator', true, `Workflow complet - Score: ${result.status.final_score}, Dur√©e: ${result.workflow_metadata.total_duration_ms}ms`);
            
        } catch (error) {
            this.addTestResult('Orchestrator', false, error.message);
        }
    }

    // M√©thodes utilitaires

    assert(condition, message) {
        if (!condition) {
            throw new Error(`Assertion √©chou√©e: ${message}`);
        }
        console.log(`  ‚úì ${message}`);
    }

    addTestResult(component, success, details) {
        this.testResults.push({
            component,
            success,
            details,
            timestamp: new Date().toISOString()
        });
        
        const status = success ? '‚úÖ' : '‚ùå';
        console.log(`${status} ${component}: ${details}`);
    }

    displayResults() {
        console.log('\n' + '=' .repeat(50));
        console.log('üìä R√âSULTATS DES TESTS');
        console.log('=' .repeat(50));

        const totalTests = this.testResults.length;
        const successfulTests = this.testResults.filter(r => r.success).length;
        const failedTests = totalTests - successfulTests;

        console.log(`\nTests ex√©cut√©s: ${totalTests}`);
        console.log(`Succ√®s: ${successfulTests}`);
        console.log(`√âchecs: ${failedTests}`);
        console.log(`Taux de r√©ussite: ${Math.round((successfulTests / totalTests) * 100)}%`);

        if (failedTests > 0) {
            console.log('\n‚ùå Tests √©chou√©s:');
            this.testResults
                .filter(r => !r.success)
                .forEach(result => {
                    console.log(`  - ${result.component}: ${result.details}`);
                });
        }

        if (this.errors.length > 0) {
            console.log('\nüö® Erreurs critiques:');
            this.errors.forEach(error => {
                console.log(`  - ${error.message}`);
            });
        }

        console.log('\n‚ú® Tests termin√©s !');
    }
}

// Ex√©cution des tests si le script est appel√© directement
if (require.main === module) {
    const tester = new AgentTester();
    tester.runAllTests().catch(error => {
        console.error('üí• Erreur fatale lors des tests:', error);
        process.exit(1);
    });
}

module.exports = AgentTester;